# Step 2

In this step, we will build a very simple test setup for the existing code we have.

- [Step 2](#step-2) - [information Points](#information-points)
		- [State Transition, Background Knowledge](#state-transition-background-knowledge)
		- [In the code](#in-the-code)


## State Transition, Background Knowledge

* at this point, we have to compose a runtime out of our pallet, and the system pallet. This
  requires us to understand the relation between the two.

In written form

* A runtime is a `struct Runtime` that implements `Config` of *all pallets*.
* `struct Runtime` is in itself generated by `construct_runtime!()` macro, that also needs the list
  of all pallets. Details of this macro beyond the scope.



## In the code

* First, we implement `frame_system::Config for Runtime`. Most of the implementation is being
  automatically derived from `derive_impl`, which brings in a sensible set of configs for testing.
  Some of the types are dependent on the runtime, so they cannot have defaults, such as `Runtime*`.
  We will learn more about this later.

* `frame_system::config_preludes::TestDefaultConfig` defined `type AccountId = u64`. So this is our
  account id type. This can be represented as `<Runtime as frame_system::Config>::AccountId`.

> This is the power that generics give us in substrate. Imagine how hard testing would have been, if
> you had to use a real account id for testing.

* impl `pallet::Config` for `Runtime` is empty, because our pallet has no configurations.

* Any code in substrate accessing storage must be wrapped in `TestState`'s `execute_with` method.
  So, we make a helper function to create a `TestState` with some initial data.

* Notice how what used to be `TotalIssuance::<T>::get()` in the actual pallet code is now
  `TotalIssuance::<Runtime>::get()`? Anywhere that we used to say `<T: Config>` within the pallet,
  we can now replace it with `<Runtime>`. Recall:

  > A runtime is a `struct Runtime` that implements `Config` of *all pallets*.

* Tests should be self-explanatory. We cover a success-path of transfer and mint, and check that the
  storages have been updated properly.

* some suggested guide lines about writing tests, presented as extra detail:
  * We suggest writing one test for each success-path of a dispatchable, and one for each
    failure-path. In this step, we are not fully covering that yet.
  * For each tests, try and maintain a "given, when, then" mental model.
  * In that spirit, it helps to have a helper method (or a Builder pattern, if you feel fancy) to
    create the initial state, and have a test called `basic_setup` or similar that ensures the
    initial state of the pallet is correct.

As a next step, you should write a test for the case of sending more balance that one has (eg. Alice
transferring 200) yourself.

In general, this was our first baby-step in "interacting" with the pallet that we have built. Next
we will continue on the same path, and before writing any further logic:

1. integrate this pallet into a real runtime ("which will look fairly similar to the test setup we
   had here").

2. interact with it using:
   * PJS-Apps
   * PJS-API/CAPI
   * SubXT
